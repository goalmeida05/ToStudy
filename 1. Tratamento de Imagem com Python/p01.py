# -*- coding: utf-8 -*-
"""Cópia de 2020-2-INF101-Pratica01-esqueleto.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/19q_4tNQpDYvMRdXOplF5GcF3fTp_16KI

INF101 - Introdução à Programação II  
PER-2  
**Prática 01 - Arranjos e Processamento de Imagens**  

---
- Estudante: *Gustavo de Oliveira Almeida* (*gustavo.o.almeida@ufv.br*)
- Matrícula: *86755*  
- Data: 04 / 02 / 2021  
- Atualização: DD / MM / AAAA 
---

## Descrição do programa:

Temos um programa que ao escolher uma imagem colorida, este irá transformá-la em tons de cinza e então esta imagem passará por um processo chamado image embossing que é uma técnica que faz com que cada pixel da imagem seja reposto por um realce ou uma sombra, isso dependendo das fronteiras entre claro-escuro da imagem.

# Classe Imagem

Não alterar esse código.
"""

# ATENÇÂO:
# Não modifique esse código.
# 
# Métodos disponíveis:
# mostrar()
# copia()
# salvar( $NOME-DO-ARQUIVO$ )

from PIL import Image

import urllib
import requests
from urllib.error import HTTPError

class Imagem(object):

    largura = altura = 0

    def initVars( self ):
        self._inGetSet = False
        self._y = 0
    
    def abrir( self, filename ):
        self.initVars()

        try: # valid URL
            f = urllib.request.urlopen(filename)
            print('Abrindo imagem de URL.')

            self.im = Image.open(requests.get(filename, stream=True).raw)

        except ( ValueError , HTTPError ):  # invalid URL
            print('Abrindo imagem de arquivo.')

            try :
              self.im = Image.open( filename ) 
            except FileNotFoundError :
              print( 'Arquivo não existe. Tenha certeza de que foi feito o'
                     ' upload deste arquivo na seção atual. Para isso, '
                     'verifique se o mesmo está na pasta do Google Colab.' )
              raise NameError('Arquivo não encontrado.')
            
        self.largura, self.altura = self.im.size
        
    def __init__( self, filename='' ):
        if filename == '':
            self.initVars()
        else: self.abrir( filename )
        
    def mostrar( self ):
        # self.im.show()
        display(self.im)
        
    def copia( self ):
        im2 = Imagem()
        im2.im = self.im.copy()
        im2.largura = self.largura
        im2.altura = self.altura
        return im2
        
    def salvar( self, filename ):
        self.im.save( filename, 'png')
        
    def __getitem__(self, yx):
        if self._inGetSet:
            self._inGetSet = False
            return self.im.getpixel( (yx, self._y) )
        else:
            self._inGetSet = True
            self._y = yx
            return self
    
    def __setitem__(self, yx, pixel):
        if self._inGetSet:
            self._inGetSet = False
            self.im.putpixel( (yx, self._y), pixel )
        else:
            self._inGetSet = True
            self._y = yx
            return self

"""# Solução da aula prática

Implemente aqui a função `tonal( imagem )` que recebe uma imagem como parâmetro e retorna a imagem em tons de cinza.
"""

def tonal(im) :
  largura_imagem = im.largura
  altura_imagem = im.altura
  for i in range( 0 , altura_imagem ) :
   for j in range( 0 , largura_imagem ) :
     r, g, b = im[i][j]
     luminancia = int(0.299 * r + 0.587 * g + 0.114 * b)
     im[i][j] = (luminancia,luminancia,luminancia)
  return im

"""Implemente aqui a função `emboss( imagem )` que recebe uma imagem em tons de cinza e retorna a imagem embossed."""

def emboss(im1) :
  im2=im1.copia()
  filtro = [[-1,-1,0],
            [-1,0,1],
            [0,1,1]]
  # Percorre todas as coordenadas da matriz original, deixando de fora as bordas.
  for y in range(1, im1.altura-1):
    for x in range(1, im1.largura-1):
      pix = 0 # inicia somatório
      # Percorre matriz de convolução.
      for i in range(0, 3):
        for j in range(0, 3):
          # Pega pixel “embaixo” da coordenada do filtro.
          r, g, b = im1[y-(1-i)][x-(1-j)]
          # Multiplica pelo filtro e soma. Para isso podemos usar apenas
          # um dos componentes (r, g ou b), já que todos são iguais.
          pix = pix + r * filtro[i][j]
      # Corrige o brilho e garante que fique entre 0 e 255.
      pix = max(0, min(255, pix+128))
      # Atribui o pixel a im2.
      im2[y][x] = (pix, pix, pix)
  return im2

"""Implemente aqui a função `main()` que abre uma imagem usando a Classe `Imagem`, transforma a imagem em tons de cinza, e chama o método emboss."""

def main():
        
    # Faça o upload do arquivo imagem e use os seguintes comandos:
    # image_path = 'fruits-700.jpg'

    # Ou leia a imagem da internet
    image_path = 'https://www.gannett-cdn.com/-mm-/92cf2cec00ba2b4a1bdd16c13e7d7e870b2efff4/c=0-109-2124-1304/local/-/media/CherryHill/2014/10/04/185689360.jpg?auto=webp&format=pjpg&width=1200'
    
    # Lê o arquivo com a imagem original e a coloca na matriz im.
    im = Imagem(image_path)
    im.mostrar()
    # Produz a imagem em tons de cinza em im1 a partir de im.
    print("Tons de cinza...")
    im1 = tonal(im)
    im1.mostrar()

    # Produz o embossing da imagem em im2 a partir de im1.
    print("Embossing...")
    im2 = emboss(im1)
    im2.mostrar()
    
    print("Fim do processamento!")

"""Chama a função `main()` para iniciar o processo."""

main()